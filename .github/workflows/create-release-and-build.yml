name: Release and Docker Image Build

on:
  push:
    branches:
      - main
      - beta
  
  pull_request:
    branches:
      - main  # Trigger on pull request merges into main
    types:
      - closed  # Only trigger when the pull request is closed (includes merges)

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    if: ${{ github.event_name != 'pull_request' || github.event.pull_request.merged == true }}
    env:
      TARGET_BRANCH: ${{ github.base_ref || github.ref_name }}
    outputs:
      version: ${{ steps.pkg_version.outputs.version }}
      should_release: ${{ steps.compare_versions.outputs.should_release }}
      target_branch: ${{ env.TARGET_BRANCH }}
      prerelease: ${{ steps.release_meta.outputs.prerelease }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '20'

    - name: Cache node modules
      uses: actions/cache@v3
      with:
        path: ~/.npm
        key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-npm-

    - name: Install dependencies
      run: npm ci

    - name: Build project
      run: npm run build

    - name: Read package.json version
      id: pkg_version
      run: echo "version=v$(jq -r '.version' package.json)" >> "$GITHUB_OUTPUT"

    - name: Find latest tagged version
      id: latest_tag
      run: |
        tag=$(git tag --list 'v*' | sort -V | tail -n1)
        echo "tag=$tag" >> "$GITHUB_OUTPUT"

    - name: Decide if release is needed
      id: compare_versions
      env:
        CURRENT_VERSION: ${{ steps.pkg_version.outputs.version }}
        LATEST_VERSION: ${{ steps.latest_tag.outputs.tag }}
      run: |
        node <<'NODE'
const fs = require('fs');
const outputPath = process.env.GITHUB_OUTPUT;
const currentRaw = process.env.CURRENT_VERSION || '';
const latestRaw = process.env.LATEST_VERSION || '';

function parse(raw) {
  if (!raw) return null;
  const match = /^v?(\d+)(?:\.(\d+))?(?:\.(\d+))?(?:-([\w.-]+))?$/.exec(raw.trim());
  if (!match) return null;
  const [, major, minor = '0', patch = '0', prerelease] = match;
  const parts = {
    major: Number(major),
    minor: Number(minor),
    patch: Number(patch),
    prerelease: [],
    raw: raw.trim(),
  };
  if (Number.isNaN(parts.major) || Number.isNaN(parts.minor) || Number.isNaN(parts.patch)) {
    return null;
  }
  if (prerelease) {
    parts.prerelease = prerelease.split('.').map((segment) => {
      return /^\d+$/.test(segment) ? Number(segment) : segment;
    });
  }
  return parts;
}

function compare(a, b) {
  if (!a) return -1;
  if (!b) return 1;
  for (const key of ['major', 'minor', 'patch']) {
    const diff = a[key] - b[key];
    if (diff !== 0) return diff;
  }
  const aPre = a.prerelease;
  const bPre = b.prerelease;
  if (aPre.length === 0 && bPre.length === 0) return 0;
  if (aPre.length === 0) return 1;
  if (bPre.length === 0) return -1;
  const len = Math.max(aPre.length, bPre.length);
  for (let i = 0; i < len; i += 1) {
    const aPart = aPre[i];
    const bPart = bPre[i];
    if (aPart === undefined) return -1;
    if (bPart === undefined) return 1;
    if (typeof aPart === 'number' && typeof bPart === 'number') {
      if (aPart !== bPart) return aPart - bPart;
    } else if (typeof aPart === 'number') {
      return -1;
    } else if (typeof bPart === 'number') {
      return 1;
    } else if (aPart !== bPart) {
      return aPart < bPart ? -1 : 1;
    }
  }
  return 0;
}

const current = parse(currentRaw);
const latest = parse(latestRaw);
let shouldRelease = false;

if (!current) {
  console.log(`Unable to parse current version "${currentRaw}". Skipping release.`);
} else if (!latest) {
  shouldRelease = true;
} else {
  shouldRelease = compare(current, latest) > 0;
}

console.log(`Current version: ${currentRaw || '(invalid)'}`);
console.log(`Latest tag: ${latestRaw || '(none)'}`);
console.log(`Should release: ${shouldRelease}`);

if (outputPath) {
  fs.appendFileSync(outputPath, `should_release=${shouldRelease}\n`);
}
NODE

    - name: Determine release metadata
      id: release_meta
      run: |
        if [ "${TARGET_BRANCH}" = "beta" ]; then
          echo "prerelease=true" >> "$GITHUB_OUTPUT"
          echo "release_name=Beta Release ${VERSION}" >> "$GITHUB_OUTPUT"
        else
          echo "prerelease=false" >> "$GITHUB_OUTPUT"
          echo "release_name=Release ${VERSION}" >> "$GITHUB_OUTPUT"
        fi
      env:
        TARGET_BRANCH: ${{ env.TARGET_BRANCH }}
        VERSION: ${{ steps.pkg_version.outputs.version }}

    - name: Create Release
      if: ${{ steps.compare_versions.outputs.should_release == 'true' }}
      uses: ncipollo/release-action@v1
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        tag: ${{ steps.pkg_version.outputs.version }}
        name: ${{ steps.release_meta.outputs.release_name }}
        prerelease: ${{ steps.release_meta.outputs.prerelease }}

  docker:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: release
    if: ${{ needs.release.result == 'success' && needs.release.outputs.should_release == 'true' }}
    env:
      VERSION: ${{ needs.release.outputs.version }}
      TARGET_BRANCH: ${{ needs.release.outputs.target_branch }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
    
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v2
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Build and Push Docker Image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: |
          ghcr.io/${{ github.repository_owner }}/${{ github.repository }}:latest
          ghcr.io/${{ github.repository_owner }}/${{ github.repository }}:${{ env.VERSION }}
          ${{ env.TARGET_BRANCH == 'beta' && format('ghcr.io/{0}/{1}:beta', github.repository_owner, github.repository) || '' }}
